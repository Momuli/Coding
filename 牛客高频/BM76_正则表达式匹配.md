## def match(self, s, pattern ):
### 动态规划

**思路:**
1. 定义二维`dp`数组:`dp[i][j]`表示`s[:i]`与`p[:j]`是否匹配
2. 假设匹配串`s`的长度为`m`, 模式串`pattern`的长度为`n`,`p[j]`分为三种情况:
* `p[j] == '.'`:此时不论`s[i]`是什么,都可以匹配,直接看`s[i-1]`和`p[j-1]`
* `p[j] == '字母'`:如果`s[i]==p[j]`,看`s[i-1]`和`p[j-1]`,否则，为`False`
* `p[j] == '*'`:此时`p[j-1]p[j]`需要看做一个整体`'cx'`:
&emsp; &emsp; 1) 如果`p[j-1]`与`s[i]`相等,则看`s[i-1]`与`p[j-1]`的匹配情况
 
&emsp; &emsp; 2) 如果`p[j-1]`与`s[i]`不匹配:则忽略`p[j-1]p[j]`,看`s[i]`与`p[j-2]`的匹配情况

3. 状态转移方程:
* 如果`p[j-1] == '.'` or `'字母'匹配`: `dp[i][j] = dp[i-1][j-1]`
* 如果`p[j-1] == '*'`:
&emsp; &emsp; `dp[i][j] = dp[i][j-2]`  # `s[i-1]`与`p[j-2]`不匹配

&emsp; &emsp; `dp[i][j] |= dp[i-1][j]`   # `s[i-1]`与`p[j-2]`匹配

4. 总结
* 末尾时'*'
* 末尾不是'*'

